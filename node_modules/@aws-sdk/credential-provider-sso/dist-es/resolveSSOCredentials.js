import { __awaiter, __generator } from "tslib";
import { GetRoleCredentialsCommand, SSOClient } from "@aws-sdk/client-sso";
import { CredentialsProviderError } from "@aws-sdk/property-provider";
import { getHomeDir } from "@aws-sdk/shared-ini-file-loader";
import { createHash } from "crypto";
import { promises as fsPromises } from "fs";
import { join } from "path";
var EXPIRE_WINDOW_MS = 15 * 60 * 1000;
var SHOULD_FAIL_CREDENTIAL_CHAIN = false;
var readFile = fsPromises.readFile;
export var resolveSSOCredentials = function (_a) {
    var ssoStartUrl = _a.ssoStartUrl, ssoAccountId = _a.ssoAccountId, ssoRegion = _a.ssoRegion, ssoRoleName = _a.ssoRoleName, ssoClient = _a.ssoClient;
    return __awaiter(void 0, void 0, void 0, function () {
        var hasher, cacheName, tokenFile, token, refreshMessage, _b, _c, e_1, accessToken, sso, ssoResp, e_2, _d, _e, accessKeyId, secretAccessKey, sessionToken, expiration;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    hasher = createHash("sha1");
                    cacheName = hasher.update(ssoStartUrl).digest("hex");
                    tokenFile = join(getHomeDir(), ".aws", "sso", "cache", cacheName + ".json");
                    refreshMessage = "To refresh this SSO session run aws sso login with the corresponding profile.";
                    _f.label = 1;
                case 1:
                    _f.trys.push([1, 3, , 4]);
                    _c = (_b = JSON).parse;
                    return [4, readFile(tokenFile, "utf8")];
                case 2:
                    token = _c.apply(_b, [_f.sent()]);
                    return [3, 4];
                case 3:
                    e_1 = _f.sent();
                    throw new CredentialsProviderError("The SSO session associated with this profile is invalid. " + refreshMessage, SHOULD_FAIL_CREDENTIAL_CHAIN);
                case 4:
                    if (new Date(token.expiresAt).getTime() - Date.now() <= EXPIRE_WINDOW_MS) {
                        throw new CredentialsProviderError("The SSO session associated with this profile has expired. " + refreshMessage, SHOULD_FAIL_CREDENTIAL_CHAIN);
                    }
                    accessToken = token.accessToken;
                    sso = ssoClient || new SSOClient({ region: ssoRegion });
                    _f.label = 5;
                case 5:
                    _f.trys.push([5, 7, , 8]);
                    return [4, sso.send(new GetRoleCredentialsCommand({
                            accountId: ssoAccountId,
                            roleName: ssoRoleName,
                            accessToken: accessToken,
                        }))];
                case 6:
                    ssoResp = _f.sent();
                    return [3, 8];
                case 7:
                    e_2 = _f.sent();
                    throw CredentialsProviderError.from(e_2, SHOULD_FAIL_CREDENTIAL_CHAIN);
                case 8:
                    _d = ssoResp.roleCredentials, _e = _d === void 0 ? {} : _d, accessKeyId = _e.accessKeyId, secretAccessKey = _e.secretAccessKey, sessionToken = _e.sessionToken, expiration = _e.expiration;
                    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
                        throw new CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
                    }
                    return [2, { accessKeyId: accessKeyId, secretAccessKey: secretAccessKey, sessionToken: sessionToken, expiration: new Date(expiration) }];
            }
        });
    });
};
