import { SignatureV4CryptoInit, SignatureV4Init } from "@aws-sdk/signature-v4";
import { HttpRequest, RequestPresigner, RequestPresigningArguments, RequestSigner, RequestSigningArguments } from "@aws-sdk/types";
import { auth as crtAuth } from "aws-crt";
export declare type AwsSigningAlgorithm = crtAuth.AwsSigningAlgorithm;
export interface CrtSignerV4Init extends SignatureV4Init {
    /**
     * The Algorithm used for the signer. Includes: SigV4, SigV4Asymmetric.
     *
     * @default [SigV4]
     */
    signingAlgorithm?: AwsSigningAlgorithm;
}
/**
 * Based aws-crt, with the same API as signing the request from SignatureV4, compatible with request Signer from SDK.
 * The difference between them is CrtSignerV4 only supports signing/presigning the request. The behavior of two signers
 * are slightly different, includes the case of headers name after signing and the CrtSignerV4 does NOT support overwrite
 * the internal check against (x-amzn-trace-id, user-agent), which will always be skipped.
 * Most importantly, CrtSignerV4 supports Signature V4 Asymmetric.
 *
 * Note: aws-crt that supports SigV4A is still a private repo https://github.com/awslabs/aws-crt-nodejs-staging/tree/sigv4a-binding
 */
export declare class CrtSignerV4 implements RequestPresigner, RequestSigner {
    private readonly service;
    private readonly regionProvider;
    private readonly credentialProvider;
    private readonly sha256;
    private readonly uriEscapePath;
    private readonly applyChecksum;
    private readonly signingAlgorithm;
    constructor({ credentials, region, service, sha256, applyChecksum, uriEscapePath, signingAlgorithm, }: CrtSignerV4Init & SignatureV4CryptoInit);
    private options2crtConfigure;
    presign(originalRequest: HttpRequest, options?: RequestPresigningArguments): Promise<HttpRequest>;
    sign(toSign: HttpRequest, options?: RequestSigningArguments): Promise<HttpRequest>;
    private getQueryParam;
    private signRequest;
    /**
     * Test-only API used for cross-library signing verification tests. Verify sign.
     *
     * Verifies:
     *  (1) The canonical request generated during sigv4a signing of the request matches what is passed in
     *  (2) The signature passed in is a valid ECDSA signature of the hashed string-to-sign derived from the
     *  canonical request
     *
     * @param request The original request used for signing
     * @param signature the actual signature computed from a previous signing of the signable
     * @param expectedCanonicalRequest expected result when building the canonical request
     * @param eccPubKeyX the x coordinate of the public part of the ecc key to verify the signature
     * @param eccPubKeyY the y coordinate of the public part of the ecc key to verify the signature
     * @param options the RequestSigningArguments used for signing
     *
     * @return True, if the verification succeed. Otherwise, false.
     */
    verifySigv4aSigning(request: HttpRequest, signature: string, expectedCanonicalRequest: string, eccPubKeyX: string, eccPubKeyY: string, options?: RequestSigningArguments): Promise<boolean>;
    verifySigv4aPreSigning(request: HttpRequest, signature: string | Array<string> | null, expectedCanonicalRequest: string, eccPubKeyX: string, eccPubKeyY: string, options?: RequestPresigningArguments): Promise<boolean>;
}
