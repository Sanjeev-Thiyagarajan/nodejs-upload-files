"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrtSignerV4 = void 0;
const querystring_parser_1 = require("@aws-sdk/querystring-parser");
const signature_v4_1 = require("@aws-sdk/signature-v4");
const aws_crt_1 = require("aws-crt");
const constants_1 = require("./constants");
const headerUtil_1 = require("./headerUtil");
function sdkHttpRequest2crtHttpRequest(sdkRequest) {
    headerUtil_1.deleteHeader(constants_1.SHA256_HEADER, sdkRequest.headers);
    const headersArray = Object.entries(sdkRequest.headers);
    const crtHttpHeaders = new aws_crt_1.http.HttpHeaders(headersArray);
    const queryString = signature_v4_1.getCanonicalQuery(sdkRequest);
    return new aws_crt_1.http.HttpRequest(sdkRequest.method, sdkRequest.path + "?" + queryString, crtHttpHeaders);
}
class CrtSignerV4 {
    constructor({ credentials, region, service, sha256, applyChecksum = true, uriEscapePath = true, signingAlgorithm = aws_crt_1.auth.AwsSigningAlgorithm.SigV4, }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.signingAlgorithm = signingAlgorithm;
        this.applyChecksum = applyChecksum;
        this.regionProvider = signature_v4_1.normalizeRegionProvider(region);
        this.credentialProvider = signature_v4_1.normalizeCredentialsProvider(credentials);
        aws_crt_1.io.enable_logging(aws_crt_1.io.LogLevel.ERROR);
    }
    async options2crtConfigure({ signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}, viaHeader, payloadHash, expiresIn) {
        const credentials = await this.credentialProvider();
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : (await this.regionProvider());
        const service = signingService !== null && signingService !== void 0 ? signingService : this.service;
        if ((signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("x-amzn-trace-id")) || (signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("user-agent"))) {
            throw new Error("internal check (x-amzn-trace-id, user-agent) is not supported to be included to sign with CRT.");
        }
        const headersUnsignable = getHeadersUnsignable(unsignableHeaders, signableHeaders);
        return {
            algorithm: this.signingAlgorithm,
            signature_type: viaHeader
                ? aws_crt_1.auth.AwsSignatureType.HttpRequestViaHeaders
                : aws_crt_1.auth.AwsSignatureType.HttpRequestViaQueryParams,
            provider: sdk2crtCredentialsProvider(credentials),
            region: region,
            service: service,
            date: new Date(signingDate),
            header_blacklist: headersUnsignable,
            use_double_uri_encode: this.uriEscapePath,
            signed_body_value: payloadHash,
            signed_body_header: this.applyChecksum && viaHeader
                ? aws_crt_1.auth.AwsSignedBodyHeaderType.XAmzContentSha256
                : aws_crt_1.auth.AwsSignedBodyHeaderType.None,
            expiration_in_seconds: expiresIn,
        };
    }
    async presign(originalRequest, options = {}) {
        if (options.expiresIn && options.expiresIn > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const request = signature_v4_1.moveHeadersToQuery(signature_v4_1.prepareRequest(originalRequest));
        const crtSignedRequest = await this.signRequest(request, await this.options2crtConfigure(options, false, await signature_v4_1.getPayloadHash(originalRequest, this.sha256), options.expiresIn ? options.expiresIn : 3600));
        request.query = this.getQueryParam(crtSignedRequest.path);
        return request;
    }
    async sign(toSign, options) {
        const request = signature_v4_1.prepareRequest(toSign);
        const crtSignedRequest = await this.signRequest(request, await this.options2crtConfigure(options, true, await signature_v4_1.getPayloadHash(toSign, this.sha256)));
        request.headers = crtSignedRequest.headers._flatten().reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
        return request;
    }
    getQueryParam(crtPath) {
        const start = crtPath.search(/\?/);
        const startHash = crtPath.search(/\#/);
        const end = startHash == -1 ? undefined : startHash;
        const queryParam = {};
        if (start == -1) {
            return queryParam;
        }
        const queryString = crtPath.slice(start + 1, end);
        return querystring_parser_1.parseQueryString(queryString);
    }
    async signRequest(requestToSign, crtConfig) {
        const request = sdkHttpRequest2crtHttpRequest(requestToSign);
        try {
            return await aws_crt_1.auth.aws_sign_request(request, crtConfig);
        }
        catch (error) {
            throw new Error(error);
        }
    }
    async verifySigv4aSigning(request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        const sdkRequest = signature_v4_1.prepareRequest(request);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const payloadHash = await signature_v4_1.getPayloadHash(request, this.sha256);
        const crtConfig = await this.options2crtConfigure(options, true, payloadHash);
        return aws_crt_1.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
    }
    async verifySigv4aPreSigning(request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options = {}) {
        if (typeof signature != "string") {
            return false;
        }
        const sdkRequest = signature_v4_1.prepareRequest(request);
        const crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
        const crtConfig = await this.options2crtConfigure(options, false, await signature_v4_1.getPayloadHash(request, this.sha256), options.expiresIn ? options.expiresIn : 3600);
        return aws_crt_1.auth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY);
    }
}
exports.CrtSignerV4 = CrtSignerV4;
function sdk2crtCredentialsProvider(credentials) {
    return aws_crt_1.auth.AwsCredentialsProvider.newStatic(credentials.accessKeyId, credentials.secretAccessKey, credentials.sessionToken);
}
function getHeadersUnsignable(unsignableHeaders, signableHeaders) {
    if (!unsignableHeaders) {
        return [];
    }
    if (!signableHeaders) {
        return [...unsignableHeaders];
    }
    const result = new Set([...unsignableHeaders]);
    for (let it = signableHeaders.values(), val = null; (val = it.next().value);) {
        if (result.has(val)) {
            result.delete(val);
        }
    }
    return [...result];
}
