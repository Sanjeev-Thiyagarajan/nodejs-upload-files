import { __assign, __awaiter, __generator, __read, __spreadArray } from "tslib";
import { parseQueryString } from "@aws-sdk/querystring-parser";
import { getCanonicalQuery, getPayloadHash, moveHeadersToQuery, normalizeCredentialsProvider, normalizeRegionProvider, prepareRequest, } from "@aws-sdk/signature-v4";
import { auth as crtAuth, http as crtHttp, io as crtIO } from "aws-crt";
import { MAX_PRESIGNED_TTL, SHA256_HEADER } from "./constants";
import { deleteHeader } from "./headerUtil";
function sdkHttpRequest2crtHttpRequest(sdkRequest) {
    deleteHeader(SHA256_HEADER, sdkRequest.headers);
    var headersArray = Object.entries(sdkRequest.headers);
    var crtHttpHeaders = new crtHttp.HttpHeaders(headersArray);
    var queryString = getCanonicalQuery(sdkRequest);
    return new crtHttp.HttpRequest(sdkRequest.method, sdkRequest.path + "?" + queryString, crtHttpHeaders);
}
var CrtSignerV4 = (function () {
    function CrtSignerV4(_a) {
        var credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.applyChecksum, applyChecksum = _b === void 0 ? true : _b, _c = _a.uriEscapePath, uriEscapePath = _c === void 0 ? true : _c, _d = _a.signingAlgorithm, signingAlgorithm = _d === void 0 ? crtAuth.AwsSigningAlgorithm.SigV4 : _d;
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.signingAlgorithm = signingAlgorithm;
        this.applyChecksum = applyChecksum;
        this.regionProvider = normalizeRegionProvider(region);
        this.credentialProvider = normalizeCredentialsProvider(credentials);
        crtIO.enable_logging(crtIO.LogLevel.ERROR);
    }
    CrtSignerV4.prototype.options2crtConfigure = function (_a, viaHeader, payloadHash, expiresIn) {
        var _b = _a === void 0 ? {} : _a, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signableHeaders = _b.signableHeaders, unsignableHeaders = _b.unsignableHeaders, signingRegion = _b.signingRegion, signingService = _b.signingService;
        return __awaiter(this, void 0, void 0, function () {
            var credentials, region, _d, service, headersUnsignable;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4, this.credentialProvider()];
                    case 1:
                        credentials = _e.sent();
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3, 2];
                        _d = signingRegion;
                        return [3, 4];
                    case 2: return [4, this.regionProvider()];
                    case 3:
                        _d = (_e.sent());
                        _e.label = 4;
                    case 4:
                        region = _d;
                        service = signingService !== null && signingService !== void 0 ? signingService : this.service;
                        if ((signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("x-amzn-trace-id")) || (signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("user-agent"))) {
                            throw new Error("internal check (x-amzn-trace-id, user-agent) is not supported to be included to sign with CRT.");
                        }
                        headersUnsignable = getHeadersUnsignable(unsignableHeaders, signableHeaders);
                        return [2, {
                                algorithm: this.signingAlgorithm,
                                signature_type: viaHeader
                                    ? crtAuth.AwsSignatureType.HttpRequestViaHeaders
                                    : crtAuth.AwsSignatureType.HttpRequestViaQueryParams,
                                provider: sdk2crtCredentialsProvider(credentials),
                                region: region,
                                service: service,
                                date: new Date(signingDate),
                                header_blacklist: headersUnsignable,
                                use_double_uri_encode: this.uriEscapePath,
                                signed_body_value: payloadHash,
                                signed_body_header: this.applyChecksum && viaHeader
                                    ? crtAuth.AwsSignedBodyHeaderType.XAmzContentSha256
                                    : crtAuth.AwsSignedBodyHeaderType.None,
                                expiration_in_seconds: expiresIn,
                            }];
                }
            });
        });
    };
    CrtSignerV4.prototype.presign = function (originalRequest, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var request, crtSignedRequest, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (options.expiresIn && options.expiresIn > MAX_PRESIGNED_TTL) {
                            return [2, Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future")];
                        }
                        request = moveHeadersToQuery(prepareRequest(originalRequest));
                        _a = this.signRequest;
                        _b = [request];
                        _c = this.options2crtConfigure;
                        _d = [options,
                            false];
                        return [4, getPayloadHash(originalRequest, this.sha256)];
                    case 1: return [4, _c.apply(this, _d.concat([_e.sent(), options.expiresIn ? options.expiresIn : 3600]))];
                    case 2: return [4, _a.apply(this, _b.concat([_e.sent()]))];
                    case 3:
                        crtSignedRequest = _e.sent();
                        request.query = this.getQueryParam(crtSignedRequest.path);
                        return [2, request];
                }
            });
        });
    };
    CrtSignerV4.prototype.sign = function (toSign, options) {
        return __awaiter(this, void 0, void 0, function () {
            var request, crtSignedRequest, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        request = prepareRequest(toSign);
                        _a = this.signRequest;
                        _b = [request];
                        _c = this.options2crtConfigure;
                        _d = [options, true];
                        return [4, getPayloadHash(toSign, this.sha256)];
                    case 1: return [4, _c.apply(this, _d.concat([_e.sent()]))];
                    case 2: return [4, _a.apply(this, _b.concat([_e.sent()]))];
                    case 3:
                        crtSignedRequest = _e.sent();
                        request.headers = crtSignedRequest.headers._flatten().reduce(function (acc, _a) {
                            var _b;
                            var _c = __read(_a, 2), key = _c[0], value = _c[1];
                            return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));
                        }, {});
                        return [2, request];
                }
            });
        });
    };
    CrtSignerV4.prototype.getQueryParam = function (crtPath) {
        var start = crtPath.search(/\?/);
        var startHash = crtPath.search(/\#/);
        var end = startHash == -1 ? undefined : startHash;
        var queryParam = {};
        if (start == -1) {
            return queryParam;
        }
        var queryString = crtPath.slice(start + 1, end);
        return parseQueryString(queryString);
    };
    CrtSignerV4.prototype.signRequest = function (requestToSign, crtConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var request, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        request = sdkHttpRequest2crtHttpRequest(requestToSign);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4, crtAuth.aws_sign_request(request, crtConfig)];
                    case 2: return [2, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error(error_1);
                    case 4: return [2];
                }
            });
        });
    };
    CrtSignerV4.prototype.verifySigv4aSigning = function (request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sdkRequest, crtRequest, payloadHash, crtConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sdkRequest = prepareRequest(request);
                        crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
                        return [4, getPayloadHash(request, this.sha256)];
                    case 1:
                        payloadHash = _a.sent();
                        return [4, this.options2crtConfigure(options, true, payloadHash)];
                    case 2:
                        crtConfig = _a.sent();
                        return [2, crtAuth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY)];
                }
            });
        });
    };
    CrtSignerV4.prototype.verifySigv4aPreSigning = function (request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sdkRequest, crtRequest, crtConfig, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (typeof signature != "string") {
                            return [2, false];
                        }
                        sdkRequest = prepareRequest(request);
                        crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
                        _a = this.options2crtConfigure;
                        _b = [options,
                            false];
                        return [4, getPayloadHash(request, this.sha256)];
                    case 1: return [4, _a.apply(this, _b.concat([_c.sent(), options.expiresIn ? options.expiresIn : 3600]))];
                    case 2:
                        crtConfig = _c.sent();
                        return [2, crtAuth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY)];
                }
            });
        });
    };
    return CrtSignerV4;
}());
export { CrtSignerV4 };
function sdk2crtCredentialsProvider(credentials) {
    return crtAuth.AwsCredentialsProvider.newStatic(credentials.accessKeyId, credentials.secretAccessKey, credentials.sessionToken);
}
function getHeadersUnsignable(unsignableHeaders, signableHeaders) {
    if (!unsignableHeaders) {
        return [];
    }
    if (!signableHeaders) {
        return __spreadArray([], __read(unsignableHeaders));
    }
    var result = new Set(__spreadArray([], __read(unsignableHeaders)));
    for (var it_1 = signableHeaders.values(), val = null; (val = it_1.next().value);) {
        if (result.has(val)) {
            result.delete(val);
        }
    }
    return __spreadArray([], __read(result));
}
